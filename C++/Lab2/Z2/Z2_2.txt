#include <iostream>
#include <windows.h>
#include <math.h>
#include <vector>

using namespace std;

class vect
{
private:
	int n; double Module;
	vector<int> res{ 0, 0 };		// Вектор, хранящий результат операций v1 и v2
	vector<int> v{ 0, 0 };

	friend void scan(vect& A);								// Дружественная функция ввода координат
	friend istream& operator >>(istream& in, vect& other);	// Дружественная функция || Перегрузка >>
	friend ostream& operator <<(ostream& ut, vect& other);	// Дружественная функция || Перегрузка <<
	friend void ResV(const vect& R);						// Дружественная функция вывода результата операций над v1 и v2
	friend void CinNumb(const vect& AB);					// Дружественная функция ввода числа n * v
	friend int ModuleVect(vect& valAB);						// Дружественная функция длины вектора
	friend void PrModVect(vect& valAB, char ch);			// Дружественная функция вывода длины вектора

public:
	vect()								// Конструктор по умолчанию
	{
		cout << "Вызвался конструктор по умолчанию\t\t" << this << endl;
	}
	vect(int x, int y)					// Конструктор с параметрами
	{
		cout << "Вызвался конструктор с параметрами\t\t" << this << endl;

		this->v[0] = x;
		this->v[1] = y;
	}
	vect(const vect& other)				// Конструктор копирования
	{
		cout << "Вызвался конструктор копирования\t\t" << this << endl;

		res[0] = other.res[0];	// Копируем результаты A в Cop_A
		res[1] = other.res[1];	// Копируем результаты A в Cop_A
	}


	vector <int> operator + (const vect& other)	// + сложение векторов
	{
		cout << "Вызвался оператор +\t\t\t\t" << this << endl;

		res[0] = v[0] + other.v[0];
		res[1] = v[1] + other.v[1];

		return res;
	}
	vector <int> operator * (int n)	// * умножение вектора на число
	{
		cout << "Вызвался оператор *\t\t\t\t" << this << endl;

		res[0] = res[0] * n;
		res[1] = res[1] * n;

		return res;
	}
	int operator * (const vect& other)	// * скалярное произведение векторов
	{
		cout << "Вызвался оператор *\t\t\t\t" << this << endl;

		int rs;
		res[0] = v[0] * other.v[0];
		res[1] = v[1] * other.v[1];
		rs = res[0] + res[1];

		return rs;
	}


	bool operator == (const vect& other)	// ==
	{
		if (Module == other.Module)
		{
			cout << "Числа равны" << endl;
			return true;
		}
		else return false;
	}
	bool operator != (const vect& other)	// !=
	{
		if (Module != other.Module)
		{
			cout << "Числа не равны" << endl;
			return true;
		}
		else  return false;
	}
	bool operator < (const vect& other)	// <
	{
		if (Module < other.Module)
		{
			cout << "Число A < числа B" << endl;
			return true;
		}
		else return false;
	}
	bool operator > (const vect& other)	// >
	{
		if (Module > other.Module)
		{
			cout << "Число A > числа B" << endl;
			return true;
		}
		else return false;
	}


	~vect()										// Деструктор
	{
		cout << "Вызвался деструктор\t\t\t\t" << this << endl;
	}
};


ostream& operator <<(ostream& ut, vect& other) // Дружественная функция ввода вектора || Перегрузка <<
{
	ut << "vect = " << "{ " << other.v[0] << ", " << other.v[1] << " }" << endl;

	return ut;
}
istream& operator >>(istream& in, vect& other) // Дружественная функция ввода вектора || Перегрузка >>
{
	cout << "x:\t"; in >> other.v[0];
	cout << "y:\t"; in >> other.v[1];

	return in;
}

void ResV(const vect& R)
{
	cout << "Результат:\t" << "{ " << R.res[0] << ", " << R.res[1] << " }" << endl << endl;
}
void Skal(int res)				// Вывод скалярного произведения векторов
{
	cout << "Результат:\t" << res << endl;
}
int ModuleVect(vect& valAB)	// Вычисление модуля комп. чис.
{
	valAB.Module = sqrt(valAB.v[0] * valAB.v[0] + valAB.v[1] * valAB.v[1]);
	
	return valAB.Module;
}
void PrModVect(vect& valAB, char ch)		// Вывод || длина вектора
{
	cout << "Длина вектора " << ch << ":\t\t" << valAB.Module << endl;
}

int cornAB(int skal, int modA, int modB)	// Угол между векторами
{
	int res;

	res = skal / (modA * modB);

	return res;
}
void PrCornAB(int res)						// Вывод угла между векторами
{
	cout << "Результат:\t" << res << endl;
}

int main()
{
	setlocale(LC_ALL, "ru");

	vect A;
	vect B;

	cout << "Vect A: " << endl; cin >> A;
	cout << A << endl;

	cout << "Vect B: " << endl; cin >> B;
	cout << B << endl;

	A.operator+(B);			// Сложение векторов
	ResV(A);

	int n;
	cout << "Введите число:\t"; cin >> n;
	A.operator*(n);			// Умножение вектора на число
	ResV(A);

	Skal(A.operator*(B));	// Скалярное произведение векторов

	char ChA = 'A'; 
	char ChB = 'B';
	ModuleVect(A); ModuleVect(B);			// Вычисление длины вектора
	cout << endl;
	PrModVect(A, ChA); PrModVect(B, ChB);	// Вывод длины вектора

	cout << endl;							// Сравнение длины векторов
	A.operator==(B);
	A.operator!=(B);
	A.operator<(B);
	A.operator>(B);

	cout << endl;
	int t = cornAB(A.operator*(B), ModuleVect(A), ModuleVect(B));	// Угол между векторами
	PrCornAB(t);													// Вывод угла между векторами

	cout << endl;
	return 0;
}