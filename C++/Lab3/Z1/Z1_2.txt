#include <iostream>
#include <windows.h>
#include <math.h>


using namespace std;

class complex
{
private:
	int** v; int rows; int cols = 2; // 0 столбец - действительная часть, 1 столбец - мнимая часть

	friend ostream& operator << (ostream& ut, complex& other);	// Вывод комплексногых чисел
	friend istream& operator >> (istream& in, complex& other);	// Ввод размера комплексных чисел и их инициализация
	friend void funk(vector<complex> other, complex other2);				// Копирование количества комплексных чисел
public:
	complex()
	{

	}
	complex(int size)	// Конструктор с параметрами
	{
		rows = size;
	}

	void ident()						// Объявление динамического массива
	{
		v = new int * [rows];

		for (int i = 0; i < rows; i++)
		{
			v[i] = new int[cols];
		}
	}
	
	int getRows()	// Геттер Rows
	{
		return rows;
	}

	~complex()	// Деструктор
	{
		for (int i = 0; i < rows; i++)
		{
			delete[] v[i];
		}
		delete[] v;
	}
};

template <class T>
class vector
{
private:
	T* v;
	int rows;
	int cols = 2;
	double Module;

	friend istream& operator >> (istream& in, vector<complex>& other);		// Дружественная функция || перегрузка >>
	friend ostream& operator << (ostream& ut, vector<complex>& other);		// Дружественная функция || перегрузка <<
public:
	void ident()						// Объявление динамического массива
	{
		v = new T[size];
	}

	~vector()
	{
		delete[] v;
	}
};

template <>
class vector<complex>
{
private:
	complex** v;
	int rows;
	int cols = 2;
	double Module;

	friend istream& operator >> (istream& in, vector<complex>& other);		// Дружественная функция || перегрузка >>
	friend ostream& operator << (ostream& ut, vector<complex>& other);		// Дружественная функция || перегрузка <<
	friend void funk(vector<complex> other, complex other2);				// Копирование количества комплексных чисел
public:
	void ident()						// Объявление динамического массива
	{
		v = new complex*[rows];

		for (int i = 0; i < rows; i++)
		{
			v[i] = new complex[cols];
		}
		
	}

	
	~vector()	// Деструктор
	{
		for (int i = 0; i < rows; i++)
		{
			delete[] v[i];
		}
		delete[] v;
	}
};

void funk(vector<complex> other, complex other2)	// Копирование количества комплексных чисел
{
	other.rows = other2.getRows();
}
istream& operator >> (istream& in, vector<complex>& other)	// Ввод вектора
{
	other.ident();
	
	for (int i = 0; i < other.rows; i++)
	{
		for (int j = 0; j < other.cols; j++)
		{
			other.v[i][0] = 
		}
	}

	

	return in;
}
ostream& operator << (ostream& ut, vector<complex>& other)	// Вывод вектора
{
	ut << "Вектор: ";
	ut << "{ ";
	for (int i = 0; i < other.rows; i++)
	{
		if (i == other.rows - 1)
		{
			ut << other.v[i];
			break;
		}
		ut << other.v[i] << ", ";
	}
	ut << " }" << endl << endl;

	return ut;
}

istream& operator >> (istream& in, complex& other)	// Ввод размера комплексных чисел и их инициализация
{
	cout << "Количество комплексных чисел:\t"; in >> other.rows;	// Вводим количество комплексных чисел
	other.ident();
	
	for (int i = 0; i < other.rows; i++)
	{
		for (int j = 0; j < other.cols; j++)
		{
			other.v[i][j] = rand() % 10;
		}
	}

	

	return in;
}
ostream& operator << (ostream& ut, complex& other)	// Вывод комплексных чисел
{
	ut << "Комплексные числа:" << endl;
	for (int i = 0; i < other.rows; i++)
	{
		if (other.v[i][1] > 0) ut << "*\t " << other.v[i][0] << " + " << other.v[i][1] << "*i" << endl;
		else if (other.v[i][1] < 0) ut << "*\t " << other.v[i][0] << "  " << other.v[i][1] << "*i" << endl;
		else ut << "*\t " << other.v[i][0] << endl;
	}

	return ut << endl;
}

int main()
{
	setlocale(LC_ALL, "ru");

	complex Ac;
	cin >> Ac;	// Ввод размера и инициализация комплексных чисел
	cout << Ac;	// Вывод комплексных чисел

	vector<complex> A;
	funk(A, Ac);// Копирование количества комплексных чисел
	cin >> A;	// Ввод вектора
	cout << A;	// Вывод вектора



	return 0;
}