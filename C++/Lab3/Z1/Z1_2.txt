#include <iostream>
#include <windows.h>
#include <math.h>


using namespace std;

class complex
{
public:
	int** v;
private:
	int rows; int cols = 2; // 0 столбец - действительная часть, 1 столбец - мнимая часть

	friend ostream& operator << (ostream& ut, complex& other);			// Вывод комплексногых чисел
	friend istream& operator >> (istream& in, complex& other);			// Ввод размера комплексных чисел и их инициализация

public:
	complex()
	{

	}
	complex(int size)	// Конструктор с параметрами
	{
		rows = size;
	}

	void ident()						// Объявление динамического массива
	{
		v = new int * [rows];

		for (int i = 0; i < rows; i++)
		{
			v[i] = new int[cols];
		}
	}
	
	int getRows()	// Геттер Rows
	{
		return rows;
	}
	int** getV()	// Геттер v
	{
		return v;
	}

	~complex()	// деструктор
	{
		cout << "Деструктор\t" << this << endl;
		for (int i = 0; i < rows; i++)
		{
			delete[] v[i];
		}
		delete[] this->v;
	}

};

template <class T>
class vector
{
private:
	T* v;
	int rows;
	int cols = 2;
	double Module;

	friend istream& operator >> (istream& in, vector<complex>& other);		// Дружественная функция || перегрузка >>
	friend ostream& operator << (ostream& ut, vector<complex>& other);		// Дружественная функция || перегрузка <<
public:
	void ident()						// Объявление динамического массива
	{
		v = new T[rows];
	}

	~vector()
	{
		delete[] v;
	}
};

template <>
class vector<complex>
{
public:
	complex* ve;
	int rows;
	int cols = 2;
	double Module;

public:
	vector(complex& other)	// Конструктор копирования || копирование rows
	{
		rows = other.getRows();
		ve = new complex[rows];
	}

	void enter(complex& other)
	{
		int** Vc = new int*[rows];
		for (int i = 0; i < rows; i++)
		{
			Vc[i] = new int[cols];
		}
		Vc = other.v;
		cout << "1" << endl;
		ve = new complex[rows];
		cout << "2" << endl;

	
		for (int i = 0; i < rows; i++)
		{
			ve[i].v[i][0] = i;
			cout << "Vot:" << endl;
			ve[i].v[i][1] = i;
		}

		/*for (int i = 0; i < rows; i++)
		{
			cout << v[i].v[i][0] = Vc[i][0];
		}*/
	}

	void ident()						// Объявление динамического массива
	{
		ve = new complex[rows];
	}

	
	~vector()	// Деструктор
	{
		delete[] ve;
	}
};


//istream& operator >> (istream& in, vector<complex>& other)	// Ввод вектора
//{
//	complex temp;
//	other.ident(); // Объявление динамического массива
//	
//	for (int i = 0; i < other.rows; i++)
//	{
//		for (int j = 0; j < other.cols; j++)
//		{
//			other.v[i][0] =
//		}
//	}
//
//	
//
//	return in;
//}
ostream& operator << (ostream& ut, vector<complex>& other)	// Вывод вектора
{
	ut << "Вектор: ";
	ut << "{ ";
	for (int i = 0; i < other.rows; i++)
	{
		if (i == other.rows - 1)
		{
			ut << other.ve[i];
			break;
		}
		ut << other.ve[i] << ", ";
	}
	ut << " }" << endl << endl;

	return ut;
}

istream& operator >> (istream& in, complex& other)	// Ввод размера комплексных чисел и их инициализация
{
	cout << "Количество комплексных чисел:\t"; in >> other.rows;	// Вводим количество комплексных чисел
	other.ident();
	
	for (int i = 0; i < other.rows; i++)
	{
		for (int j = 0; j < other.cols; j++)
		{
			other.v[i][j] = rand() % 10;
		}
	}

	

	return in;
}
ostream& operator << (ostream& ut, complex& other)	// Вывод комплексных чисел
{
	ut << "Комплексные числа:" << endl;
	for (int i = 0; i < other.rows; i++)
	{
		if (other.v[i][1] > 0) ut << "*\t " << other.v[i][0] << " + " << other.v[i][1] << "*i" << endl;
		else if (other.v[i][1] < 0) ut << "*\t " << other.v[i][0] << "  " << other.v[i][1] << "*i" << endl;
		else ut << "*\t " << other.v[i][0] << endl;
	}

	return ut << endl;
}

int main()
{
	setlocale(LC_ALL, "ru");

	complex Ac;
	cin >> Ac;	// Ввод размера и инициализация комплексных чисел
	cout << Ac;	// Вывод комплексных чисел

	vector<complex> A(Ac);
	//A.enter(Ac);
	//cout << A;	// Вывод вектора



	return 0;
}