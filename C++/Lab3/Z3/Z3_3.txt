#include <iostream>
#include <windows.h>
#include <math.h>
#include <fstream>
#include <ctime>
#define GREEN SetConsoleTextAttribute(name, FOREGROUND_RED)
#define WHITE SetConsoleTextAttribute(name, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN)

using namespace std;


template <class T>
class set
{
	T* Arr_Set;			// Множество элементов типа данных T
	int size;			// Размер множества элементов типа данных T

	friend istream& operator >> (istream& in, set<unsigned int>& other);		// Ввод размера комплексных чисел и их инициализация
	friend ostream& operator << (ostream& ut, set<unsigned int>& other);		// Вывод множества целых чисел
	friend void Largest_set_of_numbers(set<unsigned int>*& M, int size);		// Ищем наибольшее множество
	friend void funk_set_names(set<unsigned int>*& M, int size);				// Даём имя каждому множеству								// Имена для множеств
	friend bool presence_of_item(set<unsigned int>*& M);						// Проверка на наличие элементов при операции пересечения M1 и M2
public:
	char name;	// Название множества

public:
	set()
	{

	}
	set(const set& other)
	{
		size = other.size;		// Копируем в объект множества объединения размер temp.size
		Arr_Set = new T[size];
		for (int i = 0; i < size; i++) // Копируем в Объект множества объединения M3 результаты объединения множества M1 и M2
		{
			Arr_Set[i] = other.Arr_Set[i];
		}
	}

	void operator = (const set& other)	// Перегрузка оператора =
	{
		if (Arr_Set != nullptr) delete[] Arr_Set; // Если массив не пустой, то удаляем
		size = other.size;
		Arr_Set = new T[size];

		for (int i = 0; i < size; i++) // Копируем в Объект множества объединения M3 результаты объединения множества M1 и M2
		{
			Arr_Set[i] = other.Arr_Set[i];
		}
	}

	void def()
	{

	}
	set Union(const set& other)			// Метод объединения множеств
	{
		set temp;

		int sizearr = size + other.size;
		T* arr = new T[sizearr];
		int n = 0;
		for (int i = 0; i < size; i++)			// Добавляем M1 в массив множество объединения
		{
			arr[i] = Arr_Set[i];
			++n;
		}
		for (int i = 0; i < other.size; i++)	// Добавляем M2 в массив множество объединения
		{
			arr[n] = other.Arr_Set[i];
			n++;
		}
		for (int i = 0; i < sizearr; i++)			// Сортируем arr
		{
			for (int i = 0; i < sizearr - 1; i++)
			{
				if (arr[i] > arr[i + 1]) swap(arr[i], arr[i + 1]);
			}
		}
		int k = 0;
		temp.size = sizearr;
		temp.Arr_Set = new T[temp.size];		// Множество объединения размером size M1 + M2
		for (int i = 0; i < sizearr; i++)
		{
			if (i == sizearr - 1)
			{
				temp.Arr_Set[k] = arr[i];
				break;
			}
			if (arr[i] != arr[i + 1])
			{
				temp.Arr_Set[k++] = arr[i];
			}
		}

		delete[] arr;

		temp.size = k + 1;
		temp.Arr_Set = (T*)realloc(temp.Arr_Set, temp.size * sizeof(T));

		return temp;
	}
	set Intersection(const set& other)		// Метод пересечения множеств
	{
		set temp;

		int sizeM1 = size; int sizeM2 = other.size;
		T* arrM1 = new T[sizeM1];			//	M1
		T* arrM2 = new T[sizeM2];			//	M2
		for (int i = 0; i < sizeM1; i++)	// Копируем массив M1
		{
			arrM1[i] = Arr_Set[i];
		}
		for (int i = 0; i < sizeM2; i++)	// Копируем массив M2
		{
			arrM2[i] = other.Arr_Set[i];
		}
		for (int i = 0; i < sizeM1; i++)			// Сортируем M1
		{
			for (int i = 0; i < sizeM1 - 1; i++)
			{
				if (arrM1[i] > arrM1[i + 1]) swap(arrM1[i], arrM1[i + 1]);
			}
		}
		for (int i = 0; i < sizeM2; i++)			// Сортируем M2
		{
			for (int i = 0; i < sizeM2 - 1; i++)
			{
				if (arrM2[i] > arrM2[i + 1]) swap(arrM2[i], arrM2[i + 1]);
			}
		}

		// arr1 и arr2 хранят в себе разные элементы по возрастанию
		int n = 0;
		T* arr = new T[sizeM1 + sizeM2];			// Массив, в который будут копироваться все элементы множества M1 и M2
		for (int i = 0; i < sizeM1; i++)			// Добавляем M1 в массив множество объединения
		{
			arr[i] = arrM1[i];
			n++;
		}
		for (int i = 0; i < sizeM2; i++)	// Добавляем M2 в массив множество объединения
		{
			arr[n] = arrM2[i];
			n++;
		}
		temp.size = n;
		temp.Arr_Set = new T[temp.size];		// Множество объединения размером size M1 + M2
		for (int i = 0; i < n; i++)				// Сортируем
		{
			for (int i = 0; i < n - 1; i++)
			{
				if (arr[i] > arr[i + 1]) swap(arr[i], arr[i + 1]);
			}
		}
		int j = 0;
		for (int i = 0; i < n; i++)				// Исключаем разные элементы
		{
			if (i == n - 1) break;
			else if (arr[i] == arr[i + 1])
			{
				i++;
				temp.Arr_Set[j] = arr[i];
				j++;
			}
		}




		delete[] arrM1;
		delete[] arrM2;
		delete[] arr;

		temp.size = j; // Задаём новый размер множеству объединения
		temp.Arr_Set = (T*)realloc(temp.Arr_Set, temp.size * sizeof(T)); // Изменяем размер динамической памяти массива
		return temp;

	}
	void Add_Item()				// Метод добавления элемента в конец множества
	{
		size++;		// Увеличиваем размер множества на 1, т.к. добавляем элемент.
		Arr_Set = (T*)realloc(Arr_Set, size * sizeof(T));

		T item;
		cout << "Добавляемый элемент:\t\t\t"; cin >> item;
		Arr_Set[size - 1] = item;
	}
	void Del_Item()				// Метод удаления элемента
	{
		T item; int count = 0;
		cout << "Удаляемый элемент:\t\t\t"; cin >> item;
		for (int i = 0; i < size; i++)
		{
			for (int i = 0; i < size; i++)
			{
				if (Arr_Set[i] == item)	// Меняем местами удаляемый элемент и последний элемент множества, меняем размер size-1
				{
					Arr_Set[i] = Arr_Set[size - 1];
					Arr_Set[size - 1] = Arr_Set[i] - Arr_Set[size - 1];
					Arr_Set[i] = Arr_Set[i] - Arr_Set[size - 1];
					--size;		// Уменьшаем размер множества на 1, т.к. удаляем элемент.
					++count;
				}
			}
		}
		if (count == 0) cout << "Такого элемента во множестве " << name << " Нет." << endl;

		Arr_Set = (T*)realloc(Arr_Set, size * sizeof(T));
	}
	bool Search_Item()	// Метод, который проверяет, принадлежит ли элемент множеству
	{
		T item;
		cout << "Какой элемент искать? "; cin >> item;

		int count = 0;
		for (int i = 0; i < size; i++)
		{
			if (Arr_Set[i] == item)
			{
				cout << "Да, такой элемент есть под индексом " << i << " !" << endl;
				count++;
			}
		}
		if (count != 0) return true;

		cout << "Нет, данный элемент отсутствует в данном множестве." << endl;
		return false;
	}
	void set_name()	// Метод имена для множеств
	{
		char arr[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N','O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };
		name = arr[rand() % 26];
	}
	bool Contains(const set& other)	// Метод, который проверяет, содержит ли множество M1 множество M2
	{
		int sizeM1 = size; int sizeM2 = other.size;
		T* arrM1 = new T[sizeM1];		//	M1
		T* arrM2 = new T[sizeM2]; 		//	M2
		for (int i = 0; i < sizeM1; i++)	// Копируем массив M1
		{
			arrM1[i] = Arr_Set[i];
		}
		for (int i = 0; i < sizeM2; i++)	// Копируем массив M2
		{
			arrM2[i] = other.Arr_Set[i];
		}
		for (int i = 0; i < sizeM1; i++)			// Сортируем M1
		{
			for (int i = 0; i < sizeM1 - 1; i++)
			{
				if (arrM1[i] > arrM1[i + 1]) swap(arrM1[i], arrM1[i + 1]);
			}
		}
		for (int i = 0; i < sizeM2; i++)			// Сортируем M2
		{
			for (int i = 0; i < sizeM2 - 1; i++)
			{
				if (arrM2[i] > arrM2[i + 1]) swap(arrM2[i], arrM2[i + 1]);
			}
		}

		int j = 0;
		int sizeA1 = sizeM1;
		T* arr1 = new T[sizeA1];
		for (int i = 0; i < sizeA1; i++)				// Исключаем элементы-дубликаты из множества M1
		{
			if (i == sizeA1 - 1) arr1[j] = arrM1[i];
			else if (arrM1[i] != arrM1[i + 1])
			{
				arr1[j] = arrM1[i];
				j++;
			}
		}
		sizeA1 = j + 1;

		j = 0;
		int sizeA2 = sizeM2;
		T* arr2 = new T[sizeA2];
		for (int i = 0; i < sizeA2; i++)				// Исключаем элементы-дубликаты из множества M2
		{
			if (i == sizeA2 - 1) arr2[j] = arrM2[i];
			else if (arrM2[i] != arrM2[i + 1])
			{
				arr2[j] = arrM2[i];
				j++;
			}
		}
		sizeA2 = j + 1;

		int count = 0;
		for (int i = 0; i < sizeA2; i++)	// Считывание количество элементов множества пересечения
		{
			for (int j = 0; j < sizeA1; j++)
			{
				if (arr2[i] == arr1[j]) ++count;
			}
		}

		delete[] arrM1;
		delete[] arrM2;
		delete[] arr1;
		delete[] arr2;

		if (count == sizeA2)
		{
			cout << "Множество " << name << " Содержит множество " << other.name << endl;
			return true;
		}
		else
		{
			cout << "Множество " << name << " Не содержит множество " << other.name << endl; // Т.к. размер множества пересечения != размеру множества M2 
			return false;
		}
	}
	int getSize()
	{
		return size;
	}
	void add()		// Заполняем все элементы множества разными
	{
		ifstream ints;
		ints.open("C:\\Users\\ahgin\\Desktop\\lab3\\M.txt");
		if (!ints) cout << "Ошибка открытия файла M.txt" << endl;

		int* ran = new int[255];
		int k = 0;
		while (!ints.eof())	// Считываем в массив все значения из файла
		{
			ints >> ran[k];
			k++;
		}

		size = rand() % k;	// У каждого множество свой индивидуальный случайный размер
		Arr_Set = new unsigned int[size];

		for (int i = 0; i < size; i++)
		{
			Arr_Set[i] = ran[rand() % k];
		}

		for (int i = 0; i < size; i++)				// Сортируем
		{
			for (int i = 0; i < size - 1; i++)
			{
				if (Arr_Set[i] > Arr_Set[i + 1]) swap(Arr_Set[i], Arr_Set[i + 1]);
			}
		}
		for (int i = 0; i < size; i++)
		{
			if (Arr_Set[i] == Arr_Set[i + 1])
			{
				Arr_Set[i] = ++Arr_Set[size - 1];
			}
		}
		++Arr_Set[size - 1];

		ints.close();
	}



	~set()
	{
		delete[] Arr_Set;
	}
};

istream& operator >> (istream& in, set<unsigned int>& other)	// Ввод размера множества целых чисел и их инициализация
{
	other.add();


	return in;
}
ostream& operator << (ostream& ut, set<unsigned int>& other)	// Вывод множества целых чисел
{
	ut << " { ";
	for (int i = 0; i < other.size; i++)
	{
		ut << other.Arr_Set[i];
		if (i != other.size - 1) ut << ", ";
	}
	ut << " }";

	return ut << endl;
}

template<> void set<unsigned int>::def()
{
	cout << "Множество  " << name << " принадлежит типу данных int." << endl;
}

void funk_set_names(set<unsigned int>*& M, int size)	// Даём имя каждому множеству
{
	for (int i = 0; i < size; i++)
	{
		M[i].set_name();
	}
}
void Largest_set_of_numbers(set<unsigned int>*& M, int size) // Ищем наибольшее множество
{
	int max = 0;

	for (int i = 0; i < size; i++)
	{
		if (max < M[i].size) max = M[i].size;
	}

	for (int i = 0; i < size; i++)
	{
		if (M[i].size == max)
		{
			cout << "Наибольшее множество:\t\t\t" << M[i].name << endl;
			cout << "Количество его элементов:\t\t" << max << endl;
		}
	}
}
bool presence_of_item(set<unsigned int>*& M)		// Проверка на наличие элементов при операции пересечения M1 и M2
{
	set<unsigned int> M_Intersection;
	M_Intersection = M[0].Intersection(M[1]);
	if (M_Intersection.getSize() != 0) // Если размер множества пересечения != 0, то они пересекаются
	{
		cout << "Множества " << M[0].name << " и " << M[1].name << " пересекаются:\t " << M_Intersection;

		return true;
	}
	else
	{
		cout << "Множества " << M[0].name << " и " << M[1].name << " не пересекаются." << endl;

		return false;
	}

}
int main()
{
	setlocale(LC_ALL, "ru"); srand(time(NULL));

	//	Целые
	int size = 3; // Т.к. 3 множества
	set<unsigned int>* Set = new set<unsigned int>[size];

	funk_set_names(Set, size);	// Даём имя каждому множеству
	for (int i = 0; i < size; i++)
	{
		cin >> Set[i]; cout << "Количество элементов множества " << Set[i].name << ":\t" << Set[i].getSize() << endl;
		Set[i].def();	// Принадлежность множества к типу данных
		cout << "Множество " << Set[i].name << ":\t" << Set[i] << endl;
	}

	cout << "1." << endl;
	Largest_set_of_numbers(Set, size);	// Ищем наибольшее множество
	cout << "2." << endl;
	presence_of_item(Set);				// Проверка на наличие элементов при операции пересечения M1 и M2
	Set[0].Contains(Set[1]);			// Метод, который проверяет, содержит ли множество M1 множество M2
	Set[1].Contains(Set[0]);			// Метод, который проверяет, содержит ли множество M2 множество M1
	cout << "3." << endl;
	Set[0].Add_Item(); cout << "Множество " << Set[0].name << ":\t" << Set[0];	// Добавление элемента
	cout << "Количество элементов множества " << Set[0].name << ":\t" << Set[0].getSize() << endl;
	cout << "4." << endl;
	Set[1].Del_Item(); cout << "Множество " << Set[1].name << ":\t" << Set[1];	// Удаление элемента
	cout << "Количество элементов множества " << Set[1].name << ":\t" << Set[1].getSize() << endl;
	cout << "5." << endl;
	set<unsigned int> M_Union;
	M_Union = Set[0].Union(Set[1]);
	cout << "Объединение множества " << Set[0].name << " И " << Set[1].name << ":\t" << M_Union << endl;


	delete[] Set;
	return 0;
}