#include <iostream>
#include <windows.h>
#include <math.h>
#define GREEN SetConsoleTextAttribute(name, FOREGROUND_RED)
#define WHITE SetConsoleTextAttribute(name, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN)

using namespace std;


template <class T>
class set
{
	T* Arr_Set;		// Множество элементов типа данных T
	int size;		// Размер множества элементов типа данных T

	friend istream& operator >> (istream& in, set<int>& other);		// Ввод размера комплексных чисел и их инициализация
	friend ostream& operator << (ostream& ut, set<int>& other);		// Вывод множества целых чисел

	friend istream& operator >> (istream& in, set<double>& other);	// Ввод размера множества вещественных чисел и их инициализация
	friend ostream& operator << (ostream& ut, set<double>& other);	// Вывод множества вещественных чисел

	friend istream& operator >> (istream& in, set<char>& other);	// Ввод размера множества символов и их инициализация
	friend ostream& operator << (ostream& ut, set<char>& other);	// Вывод множества символов
public:
	set()
	{

	}
	set(const set& other)
	{
		size = other.size;		// Копируем в объект множества объединения размер temp.size
		Arr_Set = new T[size];
		for (int i = 0; i < size; i++) // Копируем в Объект множества объединения M3 результаты объединения множества M1 и M2
		{
			Arr_Set[i] = other.Arr_Set[i];
		}
	}

	void operator = (const set& other)	// Перегрузка оператора =
	{
		if (Arr_Set != nullptr) delete[] Arr_Set; // Если массив не пустой, то удаляем
		size = other.size;
		Arr_Set = new T[size];

		for (int i = 0; i < size; i++) // Копируем в Объект множества объединения M3 результаты объединения множества M1 и M2
		{
			Arr_Set[i] = other.Arr_Set[i];
		}
	}

	set Union(const set& other)			// Метод объединения множеств
	{
		set temp;

		int sizearr = size + other.size;
		T* arr = new T[sizearr];
		int n = 0;
		for (int i = 0; i < size; i++)			// Добавляем M1 в массив множество объединения
		{
			arr[i] = Arr_Set[i];
			++n;
		}
		for (int i = 0; i < other.size; i++)	// Добавляем M2 в массив множество объединения
		{
			arr[n] = other.Arr_Set[i];
			n++;
		}
		for (int i = 0; i < sizearr; i++)			// Сортируем arr
		{
			for (int i = 0; i < sizearr - 1; i++)
			{
				if (arr[i] > arr[i + 1]) swap(arr[i], arr[i + 1]);
			}
		}
		int k = 0;
		temp.size = sizearr;
		temp.Arr_Set = new T[temp.size];		// Множество объединения размером size M1 + M2
		for (int i = 0; i < sizearr; i++)
		{
			if (i == sizearr - 1)
			{
				temp.Arr_Set[k] = arr[i];
				break;
			}
			if (arr[i] != arr[i + 1])
			{
				temp.Arr_Set[k++] = arr[i];
			}
		}

		delete[] arr;

		temp.size = k + 1;
		temp.Arr_Set = (T*)realloc(temp.Arr_Set, temp.size * sizeof(T));

		return temp;
	}
	set Intersection(const set& other)		// Метод пересечения множеств
	{
		HANDLE color = GetStdHandle(STD_OUTPUT_HANDLE);
		set temp;

		int sizeM1 = size; int sizeM2 = other.size;
		T* arrM1 = new T[sizeM1];			//	M1
		T* arrM2 = new T[sizeM2];			//	M2
		for (int i = 0; i < sizeM1; i++)	// Копируем массив M1
		{
			arrM1[i] = Arr_Set[i];
		}
		for (int i = 0; i < sizeM2; i++)	// Копируем массив M2
		{
			arrM2[i] = other.Arr_Set[i];
		}
		for (int i = 0; i < sizeM1; i++)			// Сортируем M1
		{
			for (int i = 0; i < sizeM1 - 1; i++)
			{
				if (arrM1[i] > arrM1[i + 1]) swap(arrM1[i], arrM1[i + 1]);
			}
		}
		for (int i = 0; i < sizeM2; i++)			// Сортируем M2
		{
			for (int i = 0; i < sizeM2 - 1; i++)
			{
				if (arrM2[i] > arrM2[i + 1]) swap(arrM2[i], arrM2[i + 1]);
			}
		}

		// arr1 и arr2 хранят в себе разные элементы по возрастанию
		int n = 0;
		T* arr = new T[sizeM1 + sizeM2];			// Массив, в который будут копироваться все элементы множества M1 и M2
		for (int i = 0; i < sizeM1; i++)			// Добавляем M1 в массив множество объединения
		{
			arr[i] = arrM1[i];
			n++;
		}
		for (int i = 0; i < sizeM2; i++)	// Добавляем M2 в массив множество объединения
		{
			arr[n] = arrM2[i];
			n++;
		}
		temp.size = n;
		temp.Arr_Set = new T[temp.size];		// Множество объединения размером size M1 + M2
		for (int i = 0; i < n; i++)				// Сортируем
		{
			for (int i = 0; i < n - 1; i++)
			{
				if (arr[i] > arr[i + 1]) swap(arr[i], arr[i + 1]);
			}
		}
		int j = 0;
		for (int i = 0; i < n; i++)				// Исключаем разные элементы
		{
			if (i == n - 1) break;
			else if (arr[i] == arr[i + 1])
			{
				i++;
				temp.Arr_Set[j] = arr[i];
				j++;
			}
		}




		delete[] arrM1;
		delete[] arrM2;
		delete[] arr;

		temp.size = j; // Задаём новый размер множеству объединения
		temp.Arr_Set = (T*)realloc(temp.Arr_Set, temp.size * sizeof(T)); // Изменяем размер динамической памяти массива
		return temp;
	}
	void Add_Item(T item)		// Метод добавления элемента в конец множества
	{
		size++;		// Увеличиваем размер множества на 1, т.к. добавляем элемент.
		Arr_Set = (T*)realloc(Arr_Set, size * sizeof(T));
		Arr_Set[size - 1] = item;
	}
	void Del_Item()				// Метод удаления элемента
	{
		size--;		// Уменьшаем размер множества на 1, т.к. удаляем элемент.
		Arr_Set = (T*)realloc(Arr_Set, size * sizeof(T));
	}
	bool Search_Item()	// Метод, который проверяет, принадлежит ли элемент множеству
	{
		T item;
		cout << "Какой элемент искать? "; cin >> item;

		int count = 0;
		for (int i = 0; i < size; i++)
		{
			if (Arr_Set[i] == item)
			{
				cout << "Да, такой элемент есть под индексом " << i << " !" << endl;
				count++;
			}
		}
		if (count != 0) return true;

		cout << "Нет, данный элемент отсутствует в данном множестве." << endl;
		return false;
	}
	void add()		// Заполняем все элементы множества разными
	{
		for (int i = 0; i < size; i++)
		{
			Arr_Set[i] = rand() % 10;
		}

		for (int i = 0; i < size; i++)				// Сортируем
		{
			for (int i = 0; i < size - 1; i++)
			{
				if (Arr_Set[i] > Arr_Set[i + 1]) swap(Arr_Set[i], Arr_Set[i + 1]);
			}
		}
		for (int i = 0; i < size; i++)
		{
			if (Arr_Set[i] == Arr_Set[i + 1])
			{
				Arr_Set[i] = ++Arr_Set[size - 1];
			}
		}
		++Arr_Set[size - 1];
	}

	~set()
	{
		delete[] Arr_Set;
	}
};

template<> void set<double>::add()
{
	for (int i = 0; i < size; i++)
	{
		Arr_Set[i] = sqrt(rand() % 110);
	}

	for (int i = 0; i < size; i++)				// Сортируем
	{
		for (int i = 0; i < size - 1; i++)
		{
			if (Arr_Set[i] > Arr_Set[i + 1]) swap(Arr_Set[i], Arr_Set[i + 1]);
		}
	}

	for (int i = 0; i < size; i++)
	{
		for (int i = 0; i < size - 1; i++)
		{
			if (Arr_Set[i] == Arr_Set[i + 1])	// Меняем местами удаляемый элемент и последний элемент множества, меняем размер size-1
			{
				Arr_Set[i] = Arr_Set[size - 1]++;
			}
		}
	}
}
template<> void set<char>::add()
{
	for (int i = 0; i < size; i++)
	{
		Arr_Set[i] = 'a' + rand() % ('z' - 'a' + 1);
	}

	for (int i = 0; i < size; i++)				// Сортируем
	{
		for (int i = 0; i < size - 1; i++)
		{
			if (Arr_Set[i] > Arr_Set[i + 1]) swap(Arr_Set[i], Arr_Set[i + 1]);
		}
	}

	int j = 0;
	for (int i = 0; i < size; i++)
	{
		for (int i = 0; i < size - 1; i++)
		{
			if (Arr_Set[i] == Arr_Set[i + 1])	// Меняем местами удаляемый элемент и последний элемент множества, меняем размер size-1
			{
				Arr_Set[i] = 'A' + rand() % ('Z' - 'A' + 1);
			}
		}
	}
}

istream& operator >> (istream& in, set<int>& other)	// Ввод размера множества целых чисел и их инициализация
{
	in >> other.size;
	other.Arr_Set = new int[other.size];
	other.add();

	return in;
}
ostream& operator << (ostream& ut, set<int>& other)	// Вывод множества целых чисел
{
	ut << " { ";
	for (int i = 0; i < other.size; i++)
	{
		ut << other.Arr_Set[i];
		if (i != other.size - 1) ut << ", ";
	}
	ut << " }";

	return ut << endl;
}

istream& operator >> (istream& in, set<double>& other)	// Ввод размера множества вещественных чисел и их инициализация
{
	in >> other.size;
	other.Arr_Set = new double[other.size];
	other.add();

	return in;
}
ostream& operator << (ostream& ut, set<double>& other)	// Вывод множества вещественных чисел
{
	ut << " { ";
	for (int i = 0; i < other.size; i++)
	{
		ut << other.Arr_Set[i];
		if (i != other.size - 1) ut << ", ";
	}
	ut << " }";

	return ut << endl;
}

istream& operator >> (istream& in, set<char>& other)	// Ввод размера множества символов и их инициализация
{
	in >> other.size;
	other.Arr_Set = new char[other.size];
	other.add();

	return in;
}
ostream& operator << (ostream& ut, set<char>& other)	// Вывод множества символов
{
	ut << " { ";
	for (int i = 0; i < other.size; i++)
	{
		ut << other.Arr_Set[i];
		if (i != other.size - 1) ut << ", ";
	}
	ut << " }";

	return ut << endl;
}

char select()
{
	char a;
	cout << "Какой тип данных элементов множества вы хотите использовать?" << endl;
	cout << "i - int, d - double, c - char" << endl; cin >> a;
	return a;
}
void integ()	// Работа с целыми числами
{
	//	Целые
	set<int> A;
	cout << "Введите количество целых элементов множества A:\t"; cin >> A;
	cout << "Множество A:\t\t"; cout << A << endl;
	set<int> B;
	cout << "Введите количество целых элементов множества B:\t"; cin >> B;
	cout << "Множество B:\t\t"; cout << B << endl;

	set<int> Mi_Union; set<int> Mi_Intersection;
	Mi_Union = A.Union(B); Mi_Intersection = A.Intersection(B);
	cout << "Множество A и B\t\t" << Mi_Union;
	cout << "Множество A пер. B:\t" << Mi_Intersection << endl;

	cout << "Множество A:\t\t"; A.Del_Item(); cout << A;			// Удаление элемента и вывод множества
	cout << "Множество A:\t\t"; A.Add_Item(100); cout << A;			// Добавление элемента и вывод множества
	cout << "Множество A:\t\t"; A.Del_Item(); cout << A << endl;	// Удаление элемента и вывод множества

	cout << "Поиск элемента множества A." << endl; A.Search_Item(); cout << endl;
	cout << "Поиск элемента множества B." << endl; B.Search_Item(); cout << endl;
}
void dbl()		// Работа с вещественными числами
{
	// Вещественные
	set<double> Ad;
	cout << "Введите количество вещественных элементов множества A:\t"; cin >> Ad;
	cout << "Множество A:\t\t"; cout << Ad << endl;

	set<double> Bd;
	cout << "Введите количество вещественных элементов множества B:\t"; cin >> Bd;
	cout << "Множество B:\t\t"; cout << Bd << endl;

	set<double> Md_Union; set<double> Md_Intersection;
	Md_Union = Ad.Union(Bd); Md_Intersection = Ad.Intersection(Bd);
	cout << "Множество A и B:\t" << Md_Union;
	cout << "Множество A пер. B:\t" << Md_Intersection << endl;

	cout << "Множество B:\t\t"; Bd.Del_Item(); cout << Bd;			// Удаление элемента и вывод множества
	cout << "Множество B:\t\t"; Bd.Add_Item(3.1412); cout << Bd;	// Добавление элемента и вывод множества
	cout << "Множество B:\t\t"; Bd.Del_Item(); cout << Bd << endl;	// Удаление элемента и вывод множества

	cout << "Поиск элемента множества A." << endl; Ad.Search_Item(); cout << endl;
	cout << "Поиск элемента множества B." << endl; Bd.Search_Item(); cout << endl;
}
void chr()		// Работа с символьными числами
{
	// Символьные
	set<char> Ac;
	cout << "Введите количество символов множества A:\t"; cin >> Ac;
	cout << "Множество A:\t\t"; cout << Ac << endl;

	set<char> Bc;
	cout << "Введите количество символов множества B:\t"; cin >> Bc;
	cout << "Множество B:\t\t"; cout << Bc << endl;

	set<char> Mc_Union; set<char> Mc_Intersection;
	Mc_Union = Ac.Union(Bc); Mc_Intersection = Ac.Intersection(Bc);
	cout << "Множество A и B:\t" << Mc_Union;
	cout << "Множество A пер. B:\t" << Mc_Intersection << endl;

	cout << "Множество A:\t\t"; Ac.Del_Item(); cout << Ac;			// Удаление элемента и вывод множества
	cout << "Множество A:\t\t"; Ac.Add_Item('K'); cout << Ac;		// Добавление элемента и вывод множества
	cout << "Множество A:\t\t"; Ac.Del_Item(); cout << Ac << endl;	// Удаление элемента и вывод множества

	cout << "Поиск элемента множества A." << endl; Ac.Search_Item(); cout << endl;
	cout << "Поиск элемента множества B." << endl; Bc.Search_Item(); cout << endl;
}
int main()
{
	setlocale(LC_ALL, "ru");

	switch (select())
	{
	case 'i':
		cout << "Это int" << endl << endl;
		integ();	// Работа с целыми числами
		break;
	case 'd':
		cout << "Это double" << endl << endl;
		dbl();		// Работа с вещественными числами
		break;
	case 'c':
		cout << "Это char" << endl << endl;
		chr();		// Работа с символьными числами
		break;
	default:
		cout << "Таких типов данных нет" << endl;
	}

	return 0;
}
